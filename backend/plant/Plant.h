/**
 * @file Plant.h
 * @brief Defines the abstract base class for all Plant objects used in the system.
 */

#ifndef PLANT_H
#define PLANT_H

#include <string>
#include <map>
#include <vector>
#include <algorithm>
#include <iostream>

#include <boost/uuid/uuid.hpp>
#include <boost/uuid/uuid_generators.hpp>
#include <boost/uuid/uuid_io.hpp>
#include <nlohmann/json.hpp>
#include <thread>
#include <atomic>

#include "GreenSock.h"
#include "Logger.h"
// #include "ThreadSafeQueue.h"
#include <iostream>
#include <queue>
#include <memory>
#include <mutex>

class Health ;
class PlantState;
class GreenhouseStaff;

using namespace std;

/**
 * @class Plant
 * @brief Abstract base class representing a plant entity in the greenhouse simulation.
 *
 * This class serves as the foundation for all specific plant types (e.g., Succulent, Flower, Tree).
 * It provides common attributes such as category, variety, pricing, and state management,
 * and defines an interface for cloning and observer interaction.
 */
class Plant
{
    private:
        string careLevel;
        /**
         * @brief The broad category of the plant, such as "Succulent", "Flower", or "Tree".
         */
        string plantCategory;

        /**
         * @brief The specific variety within the plant category, such as "Daisy", "Cactus", or "Lemon".
         */
        string plantVariety;

        /**
         * @brief The cost to the player when purchasing the plant for cultivation in the greenhouse.
         */
        int costPrice = 0;

        /**
         * @brief The retail price at which the plant can be sold to customers.
         */
        int salePrice = 0;

        /**
         * @brief Pointer to the current state of the plant.
         */
        std::unique_ptr<PlantState> plantState;

        /**
         * @brief The type of care currently required by the plant.
         * String that can be either of the following: "water", "fertilizer", "pruning".
         */
        string careType;

        /**
         * @brief A static map linking specific plant varieties to their respective cost prices. Now, brace yourself,
         *  this is not only a declaration but a definition. This avoids linker errors and ensures that there is only
         *  a single definition of this static member 
         * @note Using integer (as opposed to float or double) for cost prices to avoid floating point rounding errors
         * 
         * vector[0] = costPrice
         * vector[1] = salePrice
         */
        inline static std::map<std::string, std::vector<int>> plantCosts{};

        /**
         * @brief List of greenhouse staff observers attached to this plant.
         */
        vector<GreenhouseStaff*> observerList;

        int decayIndex;
        std::atomic<bool> alive;
        std::thread thread;

        /**
         * @brief Unique hex string generated by boost::uuid
         */
        string id = "";

        /**
         * @brief Allow logger to be set, optional
         * @note Logger managed by Game class
         */
        inline static Logger* logger = nullptr;
        
        std::string difficulty;///< The difficulty level of caring for the plant.
        bool acceptable = false;  // Initialize to false
        bool returnable = false;

        // SafeQueue safeQueue;
        std::queue<string> notifyQ;
        std::queue<int> pruneQueue;

        std::mutex socketMtx;

        bool sellable = false;
    protected:
        /**
         *  @brief Pointer to the Health component representing the plant’s overall well-being.
         * */
        std::unique_ptr<Health> health ;
        GreenSock* socket = nullptr; // initalise it to null 

    public:
        /**
         * @brief Constructs a Plant object with the specified category and variety and difficulty.
         * @details Used as a base constructor for all specific Plant subclasses.
         * @param [in] category The general category of the plant.
         * @param [in] variety The specific variety within that category.
         * @param [in] difficulty The difficulty level of caring for the plant.
         * @section memory_management Thread-related Memory Management
         * The Dynamic Health Attribute should only be Created in the concrete Products
         * because, the type of plant determines how much water/fertilizer/pruning is required
         */
        Plant(string category, string variety,string difficulty);

        /**
         * @brief Copy constructor used for the Prototype design pattern.
         * @details Enables cloning of existing Plant objects.
         * @param [in] original Reference to the Plant object being duplicated.
         */
         Plant(const Plant&)            = delete;
       Plant& operator=(const Plant&) = delete;
        // Allow moves
        Plant(Plant&&)                 = default;
        Plant& operator=(Plant&&)      = default;
        /**
         * @brief Virtual destructor to ensure proper cleanup in derived classes.
         * NOTE - Additional Clean Up functionality for Thread Behaviour:
         *  - Deletes the dynamically allocated Health object.
         *  - Safely stops and joins the internal background thread to prevent dangling execution.
        */
        virtual ~Plant();

        /**
         * @brief Creates and returns a clone of the current Plant instance.
         * @details This pure virtual function must be implemented by all derived classes.
         * @return A pointer to the newly cloned Plant object.
         */
        virtual Plant* clone() = 0;

        string getCareLevel();
        /**
         * @brief Retrieves the category of the plant.
         * @return The category name as a string.
         */
        string getPlantCategory();

        /**
         * @brief Retrieves the variety of the plant.
         * @return The variety name as a string.
         */
        string getPlantVariety();

        /**
         * @brief Retrieves the purchase cost of the plant.
         * @return The cost price as an integer value.
         */
        int getCostPrice();

        /**
         * @brief Retrieves the selling price of the plant.
         * @return The sale price as an integer value.
         */
        float getSalePrice();

        /**
         * @brief Retrieves the difficulty level of caring for the plant.
         * @return The difficulty level as a string.
         */
        std::string getDifficulty();

        /**
         * @brief Displays the plant’s details to the console for testing and debugging.
         * @details This method is intended for validation and developer testing purposes only.
         */
        void display();

        /**
         * @brief Gets the current state of the plant.
         * @return Pointer to the current PlantState object
         */
        PlantState* getState();

        string getStateAsString();

        /**
         * @brief Attaches a greenhouse staff observer to this plant.
         * Adds a staff member to the observer list so they will be notified
         * when the plant requires care.
         * @param ob Pointer to the GreenhouseStaff observer to attach
         */
        void attach(GreenhouseStaff* ob);

        /**
         * @brief Detaches a greenhouse staff observer from this plant.
         * Removes a staff member from the observer list so they will no longer
         * be notified about this plant's care requirements.
         * @param ob Pointer to the GreenhouseStaff observer to detach
         */
        void detach(GreenhouseStaff* ob);

        /**
         * @brief Notifies all attached observers about the plant's care needs.
         * Iterates through the observer list and calls update() on each staff
         * member, informing them about the required care type.
         * @param careType The type of care the plant requires
         */
        void notify(const string& careType);

        string getCareType();

        /**
         * @brief Sets a new state for the plant.
         * Transitions the plant to a new state, following the State pattern.
         * The previous state is deleted and replaced with the new state.
         * @param plantState Pointer to the new PlantState to set
         */
        void setState(PlantState* plantState);

        /**
         * @brief Requests the plant's state to handle its current behaviour.
         * Delegates behaviour to the current PlantState by calling its handle() method.
         */
        void request();

        /**
         * @brief Starts the background thread that manages the plant’s lifecycle.
         * Launches the thread running the `run()` method, which periodically decays
         * the plant's health attributes and triggers observer notifications when care is needed.
         */
        void start()    ;  // start the thread

        /**
         * @brief Waits for the background thread to finish execution.
         * Ensures that any running thread is safely joined before object destruction,
         * preventing undefined behaviour or resource leaks.
         */
        void join()     ;   // join the thread

        /**
         * @brief Signals the plant's background thread to stop execution.
         * Sets the `alive` flag to false, allowing the `run()` loop to terminate gracefully.
         *  Typically followed by a call to `join()` to ensure the thread fully exits.
         */
        void stop()     ;   // signal the thread to stop


        /**
         * @brief Main loop executed by the plant’s background thread.
         * Periodically decreases water, fertilizer, and pruning values (simulating decay).
         * If any health parameter falls below a threshold, notifies greenhouse staff observers.
         * Continues running until the plant dies or `stop()` is called.
         */
        void run()      ;


        /**
         * @brief Retrieves the Health object associated with this plant.
         * This allows the greenhouse staff to make use of the appropriate handle
         * functions in the Health Class
         * @return Pointer to the plant’s Health component.
         */
        Health* getHealth()  ;

        /**
         * @brief Computes the plant’s overall health score.
         * The score is calculated as the sum of normalized water, fertilizer,
         * and pruning values. A lower score indicates declining health.
         * @return A floating-point value representing the plant’s current health.
         */
        float healthScore() ;

        void setSocket(GreenSock* sock) ; 

        void alert(string& careType, GreenSock* sock) ;
       
        bool isSellable() ; 
        
        /**
         * @brief Static method to set static member variable plantCosts
         * @param[in] plantCosts maps the plant variety to it's integer price
         */
        static void setPlantCosts(map<string, vector<int>> plantCosts);

        /**
         * @brief Used to stub plantCosts static variable when testing plants
         *  without creating game, ensuring that there are no invalid reads, variable
         *  instantiated before use
         */
        static void stubPlant();

        /**
         * @brief return plantCosts for testing purposes
         */
        static map<string, vector<int>> getPlantCosts();

        /**
         * @brief Getter for plant ID
         */
        string getId();

        /**
         * @brief Sets whether the plant is returnable by customers.
         * @param returnable Boolean indicating if the plant is returnable.
         */
        void setReturnable(bool returnable);
        /**
         * @brief Checks if the plant is returnable by customers.
         * @return True if the plant is returnable, false otherwise.
         */
        bool isReturnable();

        /**
         * @brief Setter for logger
         */
        static void setLogger(Logger* logger);
        /**
         * @brief Generate + set id member variabe
         * @example f08186d9-407d-477c-bbaa-1ba9c83a5297
         */
        void generateId();
        /**
         * @brief Adds specific plant log message, includes plant ID
         */
        void newPlantLog(string message);
        void setAcceptable(bool acceptable);
        /**
         * @brief Checks if the plant is acceptable to customers.
         * @return True if the plant is acceptable, false otherwise.
         */
        bool isAcceptable();

        string getWaterLevel();
        string getFertilizerLevel();
        string getPruningLevel();

        void queueNotify(string task);
        void queuePrune();
};
#endif
